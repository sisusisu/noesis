<?xml version="1.0"  encoding="ISO-8859-1" ?> 
<?xml-stylesheet type="text/xsl" href="../book.xsl"?>


<document>
<title>Graph Algorithms</title>

<document>
<tag>graph-representation</tag>
<title>Graph representation</title>

<document>
<tag>graph-representation-matrix</tag>
<title>Adjacency matrix</title>

<text>
The most elementary representation of a graph is the adjacency matrix, also known as the connection matrix.
</text>

</document>

<document>
<tag>graph-representation-lists</tag>
<title>Adjacency lists</title>
</document>

</document>


<document>
<tag>graph-exploration</tag>
<title>Graph exploration</title>

<document>
<tag>graph-exploration-dfs</tag>
<title>Depth-first search</title>
</document>

<document>
<tag>graph-exploration-bfs</tag>
<title>Breadth-first search</title>
</document>

</document>


<document>
<tag>graph-spanning-trees</tag>
<title>Minimum spanning trees</title>

<text>
++ Minimum Spanning Trees: Kruskal &amp; Prim. Naive implementation <eqn>O(m^2)</eqn> for Kruskal's algorithm, <eqn>O(n^3)</eqn> for Prim's algorithm
</text>

</document>


<document>
<tag>graph-shortest-paths</tag>
<title>Shortest paths</title>
</document>

<document>
<tag>graph-flow</tag>
<title>Network flow: Maximum flow and minimum cuts</title>
</document>

<document>
<tag>graph-algorithm-catalog</tag>
<title>A catalog of graph algorithms</title>

<text>
Graphs of order n (nodes) and size m (links)...
</text>

<text>
The following problems can be solved with algorithms that run in linear time (i.e. <eqn>O(n+m)</eqn>):
</text>

<text>
The following algorithms require <eqn>O(m \log n)</eqn> time:
</text>

<text>
Hard problems (NP):
</text>

<list>

<item>Hamiltonian path / TSP</item>

<item>Eulerian path</item>

</list>


<note>
<title>The dominance pecking order in algorithm analysis</title>

<equation>
n! >> c^n >> n^3 >> n^2 >> n^{1+\epsilon} >> n \log n 
</equation>

<equation>
>> n >> sqrt(n) >> \log^2 n >> \log n
</equation>

<equation>
>> \log n / \log \log n >> \log \log n >> \alpha(n) >> 1
</equation>

<text>
<cite>Skiena 2008</cite>, page 56:
</text>

<list>
<item><eqn>\alpha(n)</eqn>: Inverse Ackerman's function (union-find data structure).</item>
<item><eqn>\log n / \log \log n</eqn>: Height of an n-leaf tree of degree <eqn>d = \log n</eqn>.</item>
<item><eqn>n^{1+\epsilon}</eqn>, e.g. <eqn>2^c*n^{1+1/c}</eqn> where <eqn>c</eqn> cannot be arbitrarily large (<eqn>2^c!</eqn>).</item>
</list>

<text>
The importance of data structures @ <cite>Skiena 2008</cite>, chapter 3, page 65: <q>Changing the data structure does not change the correctness of the program, since we presumably replace a correct implementation with a different correct implementation. However, the new implementation of the data type realizes different tradeoffs in the time to execute various operations, so the total performance can improve dramatically</q>.
</text>

<text>
3 fundamental ADTs: containers, dictionaries &amp; priority queues
</text>

</note>



<!--
<figure>
<title>Image example (default file type)</title>
<image scale="20" file="image/cover/0321127420"/>
</figure>

<figure>
<title>Another image example (specific file type)</title>
<image scale="20" file="image/cover/0321117425.jpg" type="jpg"/>
</figure>

<text>
Inline image:
</text>

<image scale="20" file="image/cover/0321117425.jpg" type="jpg"/>
-->

</document>


<document>
<tag>graph-algorithms-notes</tag>
<title>Bibliographic notes</title>


<text>
<cite>Skiena 2008</cite>, <cite>Kleinberg and Tardos 2005</cite>
</text>


<text>
<cite>Grama et al. 2003</cite> includes a chapter on parallel graph algorithms.
</text>

</document>


<document>
<tag>graph-algorithms-references</tag>
<title>References</title>

<reference id="Grama et al. 2003">
 <author>Ananth Grama</author>
 <author>Anshul Gupta</author>
 <author>George Karypis</author>
 <author>Vipin Kumar</author>
 <title>Introduction to Parallel Computing</title>
 <publisher>Addison Wesley</publisher>
 <edition>2nd edition</edition>
 <year>2003</year>
 <isbn>0201648652</isbn>
 <file>[books]/algorithms/0201648652 [Kumar] Parallel Computing.2nd.chm</file>
</reference>

<reference id="Kleinberg and Tardos 2005">
 <author>Jon Kleinberg</author>
 <author>Éva Tardos</author>
 <title>Algorithm Design</title>
 <publisher>Addison-Wesley</publisher>
 <year>2005</year>
 <isbn>0321295358</isbn>
 <file>[books]/algorithms/0321295358 [Kleinberg] Algorithm Design.pdf</file>
</reference>

<reference id="Skiena 2008">
 <author>Steven S. Skiena</author>
 <title>The Algorithm Design Manual</title>
 <publisher>Springer</publisher>
 <edition>2nd edition</edition>
 <year>2008</year>
 <isbn>1848000693</isbn>
 <file>[books]/algorithms/1848000693 [Skiena] The Algorithm Design Manual.2nd.pdf</file>
</reference>

</document>

</document>

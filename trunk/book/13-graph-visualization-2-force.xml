<?xml version="1.0"  encoding="ISO-8859-1" ?> 
<?xml-stylesheet type="text/xsl" href="../book.xsl"?>

<document>
<tag>graph-visualization-force</tag>
<title>Force-directed methods: Spring models</title>

<text>
"a good, general purpose graph-drawing heuristic models the graph as a system
of springs and then uses energy minimization to space the vertices. Let adjacent
vertices attract each other with a force proportional to (say) the logarithm of their
separation, while all nonadjacent vertices repel each other with a force proportional
to their separation distance. These weights provide incentive for all edges to be
as short as possible, while spreading the vertices apart. The behavior of such a
system can be approximated by determining the force acting on each vertex at a
particular time and then moving each vertex a small amount in the appropriate
direction. After several such iterations, the system should stabilize on a reasonable
drawing."
</text>


<text>
An example <type>graph drawing</type> algorithm is shown in Figure <ref>force-based</ref>.
</text>

<figure>
<title>Force-based algorithm.</title>
<tag>force-based</tag>
<code>
 set up initial node velocities to (0,0)
 set up initial node positions randomly // make sure no 2 nodes are in exactly the same position
 loop
     total_kinetic_energy := 0 // running sum of total kinetic energy over all particles
     for each node
         net-force := (0, 0) // running sum of total force on this particular node
         
         for each other node
             net-force := net-force + Coulomb_repulsion( this_node, other_node )
         next node
         
         for each spring connected to this node
             net-force := net-force + Hooke_attraction( this_node, spring )
         next spring
         
         // without damping, it moves forever
         this_node.velocity := (this_node.velocity + timestep * net-force) * damping
         this_node.position := this_node.position + timestep * this_node.velocity
         total_kinetic_energy := total_kinetic_energy + this_node.mass * (this_node.velocity)^2
     next node
 until total_kinetic_energy is less than some small number  // the simulation has stopped moving
</code>
</figure>


<text>
CH: A milestone of the force-directed graph drawing literature is the work by Eades
<cite>Eades 1984</cite>.  Eades' idea is to model a graph G as a mechanical system where the vertices
of G are steel rings and the edges of G are springs that connect pairs of rings. To compute a drawing of G, the rings are placed in some initial layout and let go until
the spring forces move the system to a local minimum of energy. Clearly, different
definitions of the repulsive and attractive forces that characterize the physical model
of G give rise to different drawings of G. For example, Eades' implementation of the
physical model does not reflect Hooke's law for the forces but obeys a logarithmic
function for attractive forces; also, while repulsive forces act between every pair
of vertices, attractive forces are calculated only between pairs of adjacent vertices.
More precisely, in the model of Eades, the repulsive force between any pair
(u, v) of vertices is
</text>

<equation>
f_{repulsive} (u,v) = \frac{k·uv}{d^2(u,v)}
</equation>

<text>
where d(u, v) is the Euclidean distance between the points representing u and v,
uv is the unit length vector oriented from the point representing u to the point
representing v, and k is a repulsion constant. The attractive force of two adjacent
vertices u and v is
</text>

<equation>
f_{attractive} (u,v) = \chi \log \frac{d(u,v)·vu}{l}
</equation>

<text>
where l is the zero energy length of the spring and \Chi is the stiffness constant of the
spring. To compute a drawing, one can start with an initial random placement of the
vertices and proceed iteratively to find an equilibrium configuration. For example,
a heuristic that converges to an equilibrium configuration consists of computing at
each iteration and for each vertex v the force F(v), that is, the sum of the repulsive
and attractive forces acting on v; v is then moved in the direction of F(v) by a
small amount proportional to the magnitude of F(v).
</text>


<text>
++ The Kamada-Kawai's graph drawing algorithm, chosen for its ability to represent
naturally the most important elements in the center of the representation (the backbone), <cite>Kamada and Kawai 1989</cite>
</text>

<text>
++ Fruchterman and Reingold's graph drawing algorithm <cite>Fruchterman and Reingold 1991</cite>...
</text>


</document>

<?xml version="1.0"  encoding="ISO-8859-1" ?> 
<?xml-stylesheet type="text/xsl" href="../book.xsl"?>


<document>
<tag>graph-visualization-specific</tag>
<title>Methods for specific kinds of graphs</title>


<document>
<tag>graph-visualization-planar</tag>
<title>Planar graphs</title>

SKIENA

Can G be drawn in the plane such that no two edges cross? If so, produce such a drawing.

Planar drawings (or embeddings) make clear the structure of a given
graph by eliminating crossing edges, which can be confused as additional vertices.
Graphs defined by road networks, printed circuit board layouts, and the like are
inherently planar because they are completely defined by surface structures.


NOTE: Obstructing subgraphs K3,3 K5

<cite>Kuratowski 1930</cite> gave the first characterization of planar graphs, namely that they do not contain a subgraph homeomorphic to K3,3 or K5. Thus, if you are still working on the exercise to embed K5, now is an appropriate time to give it up.


<cite>Fary 1948</cite> states that every planar graph can be drawn in such a way that each edge
is straight.


++ Outerplanar graphs are those that can be drawn so all vertices lie on the outer face
of the drawing. Such graphs can be characterized as having no subgraph homeomorphic
to K2,3 and can be recognized and embedded in linear time.



Planar graphs have a variety of nice properties that can be exploited to yield
faster algorithms for many problems. The most important fact to know is that
every planar graph is sparse. Euler's formula shows that |E| lt 3|V| - 6 for every
nontrivial planar graph G = (V,E). This means that every planar graph contains
a linear number of edges, and further that every planar graph contains a vertex of
degree lt 5. Every subgraph of a planar graph is planar, so there must always a
sequence of low-degree vertices to delete from G, reducing it to th



Thus, it pays to distinguish the problem of planarity testing (does a graph
have a planar drawing?) from constructing planar embeddings (actually finding
the drawing), although both can be done in linear time.

Algorithms for planarity testing begin by embedding an arbitrary cycle from the
graph in the plane and then considering additional paths in G, connecting vertices
on this cycle. Whenever two such paths cross, one must be drawn outside the cycle
and one inside. When three such paths mutually cross, there is no way to resolve
the problem, so the graph cannot be planar. Linear-time algorithms for planarity
detection are based on depth-first search, but they are subtle...

Such path-crossing algorithms can be used to construct a planar embedding by
inserting the paths into the drawing one by one. Unfortunately, because they work
in an incremental manner, nothing prevents them from inserting many vertices and
edges into a relatively small area of the drawing. Such cramping is a major problem,
for it leads to ugly drawings that are hard to understand.

Better algorithms have
been devised that construct planar-grid embeddings, where each vertex lies on a
(2n - 4) x (n - 2) grid. Thus, no region can get too cramped and no edge can
get too long. Still, the resulting drawings tend not to look as natural as one might
hope.

For nonplanar graphs, what is often sought is a drawing that minimizes the
number of crossings. Unfortunately, computing the crossing number of a graph is
NP-complete. A useful heuristic extracts a large planar subgraph of G, embeds this
subgraph, and then inserts the remaining edges one by one to minimize the number
of crossings. This won't do much for dense graphs, which are doomed to have a large
number of crossings, but it will work well for graphs that are almost planar, such
as road networks with overpasses or printed circuit boards with multiple layers.
Large planar subgraphs can be found by modifying planarity-testing algorithms to
delete troublemaking edges when encountered.


REFERENCES

<cite>Hopcroft and Tarjan 1974</cite> gave the first linear-time algorithm for drawing graphs.

<cite>Booth and Lueker 1976</cite> developed an alternate planarity-testing algorithm based on PQ-trees.

Simplified planarity-testing algorithms include
- <cite>Mehlhorn and Mutzel 1996</cite>
- <cite>Boyer et al. 2004</cite>
- <cite>Shih and Hsu 1999</cite>


Efficient 2n x n planar grid embeddings were first developed by 
<cite>de Fraysseix et al. 1990</cite>


The book by <cite>Nishizeki and Rahman 2004</cite> provides a good overview of the spectrum of planar drawing algorithms.

</document>


<document>
<tag>graph-visualization-trees</tag>
<title>Trees</title>

Create a nice drawing of trees, i.e. graphs without cycles (always planar, can be drawn without edge crossings)


SKIENA

- Rooted trees define a hierarchical order, emanating from a single source node
identified as the root. Any drawing should reflect this hierarchical structure,
as well as any additional application-dependent constraints on the order in
which children must appear. For example, family trees are rooted, with sibling
nodes typically drawn from left to right in the order of birth.

- Free trees do not encode any structure beyond their connection topology.
There is no root associated with the minimum spanning tree (MST) of a
graph, so a hierarchical drawing will be misleading. Such free trees might
well inherit their drawing from that of the full underlying graph, such as the
map of the cities whose distances define the MST."


TECHNIQUES

- Any of the techniques for planar graphs (might be too general, too slow for particular applications).

- Assume a root is present (e.g. a center vertex might be suitable). For trees, the center always consists of either one vertex or two
adjacent vertices. This tree center can be identified in linear time by repeatedly trimming all the leaves until only the center remains.

a) Ranked embeddings - "Place the root in the top center of your page, and then
partition the page into the root-degree number of top-down strips. Deleting
the root creates the root-degree number of subtrees, each of which is assigned
to its own strip. Draw each subtree recursively, by placing its new root (the
vertex adjacent to the old root) in the center of its strip a fixed distance down
from the top, with a line from old root to new root. The output figure above
is a nicely ranked embedding of a balanced binary tree.
Such ranked embeddings are particularly effective for rooted trees used to
represent a hierarchy—be it a family tree, data structure, or corporate ladder.
The top-down distance illustrates how far each node is from the root.
Unfortunately, such repeated subdivision eventually produces very narrow
strips, until most of the vertices are crammed into a small region of the page.
Try to adjust the width of each strip to reflect the total number of nodes it
will contain, and don't be afraid of expanding into neighboring region's turf
once their shorter subtrees have been completed."

b) Radial embeddings - "Free trees are better drawn using a radial embedding,
where the root/center of the tree is placed in the center of the drawing.
The space around this center vertex is divided into angular sectors for each
subtree. Although the same problem of cramping will eventually occur, radial
embeddings make better use of space than ranked embeddings and appear
considerably more natural for free trees. The rankings of vertices in terms of
distance from the center is illustrated by the concentric circles of vertices."



REFERENCES

Heuristics for tree layout have been studied by several researchers <cite>Reingold and Tilford 1981</cite> <cite>Moen 1990</cite>

<cite>Buchheim, et al. 2006</cite> reflective of the state-of-the-art. 

Under certain aesthetic criteria, the problem is NP-complete <cite>Supowit and Reingold 1983</cite>.

</document>

<document>
<tag>graph-visualization-bipartite</tag>
<title>Bipartite graphs</title>


<text>
++ Bipartite graphs:
<cite>Eades and Wormwald 1994</cite> showed that it remains NP-hard even if there are only two layers
and the permutation of the vertices on one of them is fixed.
</text>

</document>

</document>


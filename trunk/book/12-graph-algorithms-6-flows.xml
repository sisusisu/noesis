<?xml version="1.0"  encoding="ISO-8859-1" ?> 
<?xml-stylesheet type="text/xsl" href="../book.xsl"?>

<!-- Network flows -->

<document>
<tag>graph-flow</tag>
<title>Network flows: Maximum flow and minimum cuts</title>

<text>
Interpreting weighted graphs as distribution networks where weights represent capacities
</text>

<text>
two primary classes of network flow problems:
maximum flow and minimum-cost flow:

- "The maximum-flow problem is that of finding a maximum flow of a
single commodity from a source vertex to a sink vertex that satisfies
capacity constraints on the edges and flow conservation constraints at the
vertices. "

- Associating costs with edges yields the minimum-cost flow problem. 
where we also have a targeted amount of flow f we want to send from s to t at minimum total cost.


Polynomial-time algorithms to solve maximum flow and minimum-cost flows are known.
"a surprising variety of linear programming
problems arising in practice can be modeled as network-flow problems,
and network-flow algorithms can solve these problems much faster than
general-purpose linear programming methods"

APPLICATIONS: cost-effective way to ship goods between a set of factories and a set of stores
defines a network-flow problem, as do many resource-allocation problems in communications
networks
</text>

<text>
Network flow problem: The maximum amount of flow that can be sent from s to t in a given graph.


</text>


<document>
<tag>graph-flow-algorithms</tag>
<title>Network flow algorithms</title>

<text>
The two major techniques for solving flow problems are the augmenting-path method and the preflow-push method.

- Augmenting paths: "These algorithms repeatedly find a path of positive
capacity from source to sink and add it to the flow. It can be shown that
the flow through a network is optimal if and only if it contains no augmenting
path. Since each augmentation adds something to the flow, we eventually
find the maximum. The difference between network-flow algorithms is in how
they select the augmenting path."

- "Preflow-push methods - These algorithms push flows from one vertex to another,
initially ignoring the constraint that in-flow must equal out-flow at each
vertex. Preflow-push methods prove faster than augmenting-path methods,
essentially because multiple paths can be augmented simultaneously. These
algorithms are the method of choice in practice"
</text>


<text>
The standard reference for network flow algorithms and their history is <cite>Ahuja et al. 1993</cite>. 
The fastest known general network flow algorithm runs in <eqn>O(nm \log(n^2/m))</eqn> time <cite>Goldberg and Tarjan 1988</cite>.
</text>

<!-- Augmenting paths -->

<document>
<tag>graph-flow-augmenting-paths</tag>
<title>Network flow algorithms: Augmenting paths</title>

<text>
IDEA: <b>Augmenting paths</b>
i.e. iteratively find a path of positive capacity from s to t and add it to the flow
- As in a traffic jam, the flow is limited by the most congested point.
- A flow through a network is optimal if and only if it contains no augmenting path.
</text>

<text>
MECHANISM: Directed <b>residual flow graph</b> R(G,f), where G is the graph and f the current flow
i.e. For each edge (i,j) in G with capacity c(i,j) and flow f(i,j), R can contain two edges
- an edge (i,j) with weight c(i,j)-f(i,j) if c(i,j)>f(i,j)
- an edge (j,i) with weight f(i,j)-c(i,j) if f(i,j)>0

An edge (i,j) in the residual flow graph indicates that flow can still be pushed from i to j (its weight determines the amount of its unused capacity). 

A path from s to t in the residual graph (and the minimum edge weight on this path) defines an augmenting path (and the amount of flow that can be pushed).
</text>

<text>
- For each edge in the residual graph: keep track of the amount of flow currently going through the edge as well as any unused capacity (the residual capacity)
- Initialization: create directed flow edges (i,j) and (j,i); initial flows set to 0; initial residual flows set to their capacity in the original graph.
</text>

<text>
ITERATIVE ALGORITHM
Ford-Fulkerson algorithm <cite>Ford and Fulkerson 1956</cite>
<url>http://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm</url>

- Use the augmented path to update the residual graph (transfer the maximum possible volume from the residual capacity = the path edge with the smallest amount of residual capacity; NOTE: adding positive flow to (i,j) reduces the residual capacity of (i,j) but also increases the residual capacity of (j,i), i.e. augmenting a path requires updates to both forward and reverse links along the augmenting path ).
- Terminate when no such augmenting path exists.
</text>


<text>
As described, even though the algorithm converges to the optimal solution, it may take arbitrarily long (each augmenting path might add only a little to the flow). 

Assuming all capacities in the flow network are integers, we might require up to C iterations of the Ford-Fulkerson algorithm. Since each iteration requires finding an s-t path, a problem that can be solved in O(m) time, the Ford-Fulkerson algorithm requires O(Cm) time.

The way we choose an augmenting path can severely impact the efficiency of the algorithm, specially for large integer capacities. Different approaches have been proposed:

- Scaling max-flow, i.e. looking for paths of at least \Delta capacity by using the residual graph G_f(\Delta) consisting only of edges with residual capacity of at least \Delta (for different values of \Delta, typically powers of two of decreasing value). When \Delta=1, G_f(\Delta)=G_f. The number of different values of \Delta that must be tried is bounded by 1 + \lceil log_2 C \rceil. For each value of \Delta, augmentation paths augment the network flow for at least \Delta, limiting the number of augmentations in each scaling phase to, at most, 2m, since v(f*) \leq v(f) + m 2\Delta. Since each augmentation requires O(m) time and the scaling max-flow algorithm finds a maximum flow in, at most, 2m(1 + \lceil log_2 C \rceil) augmentations, it runs in O(m^2 log_2 C) time. In other words, whereas the original Ford-Fulkerson algorithm requires time proportional to the magnitude of the capacities (a pseudo-polynomial algorithm), the scaling max-flow algorithm requires time proportional to the number of bits needed to represent those capacities (a truly polynomial time algorithm).


An alternative: Choosing the augmenting path with the fewest number of edges. This strategy leads to strongly polynomial algorithms that require O(mn) iterations, such as the ones independently developed by Dinitz andd Edmonds-Karp.
</text>

<text>
IMPLEMENTATION (Edmonds-Karp algorithm <cite>Edmonds and Karp 1972</cite>):
<url>http://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm</url>
The algorithm is identical to the Ford-Fulkerson algorithm, except that the search order when finding the augmenting path is defined. The path found must be a shortest path that has available capacity

- BFS to look for any path from the source to the sink that increases the total flow (only consider edges with residual capacity, i.e. positive residual flow)
</text>

<text>

 <cite>Edmonds and Karp 1972</cite> proved that selecting the shortest unweighted augmenting path (a.k.a. shortest geodesic path) guarantees that <eqn>O(mn)</eqn> augmentations suffice for optimization.

<eqn>O(nm^2)</eqn> running time: each augmenting path can be found in <eqn>O(m)</eqn> time, every time at least one of the <eqn>m</eqn> edges becomes saturated, the distance from the saturated edge to the source along the augmenting path must be longer than last time it was saturated, and that length is at most <eqn>n</eqn>.

Another property of this algorithm is that the length of the shortest augmenting path increases monotonically.
</text>




<text>
AN ALTENATIVE 
- the blocking flow algorithm of Dinitz
<url>http://en.wikipedia.org/wiki/Dinitz_blocking_flow_algorithm</url>
+ conceived in 1970 by the then Soviet computer scientist Yefim Dinitz, earlier than the Edmonds–Karp algorithm. The algorithm runs in O(V2E) time and is similar to the Edmonds–Karp algorithm, which runs in O(VE2) time, in that it uses shortest augmenting paths. 

Concepts: level graph and blocking flow

Dinitz blocking flow algorithm	
O(n^2m)	
In each phase the algorithms builds a layered graph with breadth-first search on the residual graph. The maximum flow in a layered graph can be calculated in O(nm) time, and the maximum number of the phases is n-1. In networks with unit capacities, Dinitz's algorithm terminates in O(n\sqrt{m}) time.

Dinitz blocking flow algorithm with dynamic trees	
O(nm \log n)	
The dynamic trees data structure speeds up the maximum flow computation in the layered graph to O(m \log n).

A link/cut tree is a type of data structure that can merge (link) and split (cut) data sets in O(log(n)) amortized time, and can find which tree an element belongs to in O(log(n)) amortized time. In the original publication, Sleator and Tarjan referred to link/cut trees as “dynamic trees”.
[Sleator, D. D.; Tarjan, R. E. (1983). "A Data Structure for Dynamic Trees". Proceedings of the thirteenth annual ACM symposium on Theory of computing - STOC '81. pp. 114. doi:10.1145/800076.802464]
[Sleator, D. D.; Tarjan, R. E. (1985). "Self-Adjusting Binary Search Trees". Journal of the ACM 32 (3): 652. doi:10.1145/3828.3835]


++ the binary blocking flow algorithm of Goldberg and Rao. 
[Andrew V. Goldberg and S. Rao (1998). "Beyond the flow decomposition barrier". J. Assoc. Comput. Mach. 45 (5): 753–782. doi:10.1145/290179.290181]

Binary blocking flow algorithm [1]		
O(m \min \{n^{2/3}, \sqrt{m}\} \log ( n^2/m ) \log U )
The value U corresponds to the maximum capacity of the network.
</text>


<text>
SUMMARY
Ford–Fulkerson algorithm:
O(mC)	
As long as there is an open path through the residual graph, send the minimum of the residual capacities on the path.
The algorithm works only if all weights are integers. Otherwise it is possible that the Ford–Fulkerson algorithm will not converge to the maximum value.

Edmonds–Karp algorithm:
O(nm^2)
A specialization of Ford–Fulkerson, finding augmenting paths with breadth-first search.

Dinitz algorithm:
O(n^2m)
Another augmenting-paths algorithm, based on level graphs and blocking flows
</text>

</document>


<!-- Preflow-push -->

<document>
<tag>graph-flow-augmenting-paths</tag>
<title>Network flow algorithms: Preflow-push methods</title>


<text>
The preflow-push maximum flow algorithm was devised by Andrew Goldberg in his Ph.D. thesis <cite>Goldberg 1986</cite>and its efficient implementation is described in <cite>Goldberg and Tarjan 1986</cite>. Goldberg, now at Microsoft Research, maintains a web site with code...

[Golberg 1986]
[GOLDBERG, A. V. A new max-flow algorithm. Tech. Rep. MIT/LCS/TM-291, Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, Mass., 1985.]
[GOLDBERG, A. V. Efficient graph algorithms for sequential and parallel computers. Ph.D. thesis, Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, Mass., 1985.]
[A V Goldberg , R E Tarjan, A new approach to the maximum flow problem, Proceedings of the 18th annual ACM symposium on Theory of computing, p.136-146, May 28-30, 1986, Berkeley, California, United States  [doi>10.1145/12130.12144] ]
[Andrew V. Goldberg and Robert E. Tarjan (1988). "A new approach to the maximum-flow problem". Journal of the ACM 35(4): 921–940. doi:10.1145/48014.61051]

[Andrew V. Goldberg , Robert E. Tarjan, Finding minimum-cost circulations by successive approximation, Mathematics of Operations Research, v.15 n.3, p.430-466, Aug. 1990  [doi>10.1287/moor.15.3.430]]
[Goldberg, A. V.; Tarjan, R. E. (1989). "Finding minimum-cost circulations by canceling negative cycles". Journal of the ACM 36 (4): 873. doi:10.1145/76359.76368] — Application of dynamic trees to min-cost circulation
</text>

<text>
IDEA: Instead of increasing the value of the flow for full augmenting paths, increase the flow on an edge-by-edge basis even when that violates the conservation condition.
</text>

<text>
Preflow: An s-t preflow is a function that maps each edge e to a nonnegative real number. This function must satisfy the capacity conditions, i.e. 0 \leq f(e) \leq c(e) for all edges but, instead of imposing the conservation condition, we require the satisfaction of an inequality: each node other than the source must have at least as much flow entering as leaving.
</text>

<equation>
\sum_{e \text{ into } v} f(e) \geq \sum_{e \text{ out of } v} f(e)
</equation>

<text>
The difference between both quantities is the excess of the preflow at node <eqn>v</eqn>. When all nodes, apart from the source and the sink, have zero excess, then we have a flow whose value <eqn>is e_f(t)=-e_f(s)</eqn>.
</text>

<text>
A preflow-push algorithm will work on a preflow until it becomes a flow...

Since flow finds its way downhill in Nature, we will label nodes with heights and push flow from higher nodes to lower nodes.
</text>


<text>
a.k.a. push-relabel algorithm
<url>http://en.wikipedia.org/wiki/Push-relabel_maximum_flow_algorithm</url>
</text>

<text>
General push-relabel maximum flow algorithm	
O(n^2m)	
The push relabel algorithm maintains a preflow, i.e. a flow function with the possibility of excess in the vertices. The algorithm runs while there is a vertex with positive excess, i.e. an active vertex in the graph. The push operation increases the flow on a residual edge, and a height function on the vertices controls which residual edges can be pushed. The height function is changed with a relabel operation. The proper definitions of these operations guarantee that the resulting flow function is a maximum flow.

Push-relabel algorithm with FIFO vertex selection rule
O(n^3)
Push-relabel algorithm variant which always selects the most recently active vertex, and performs push operations until the excess is positive or there are admissible residual edges from this vertex.

Push-relabel algorithm with dynamic trees	
O(nm log(n^2/m))	
The algorithm builds limited size trees on the residual graph regarding to height function. These trees provide multilevel push operations.
</text>

<text>
i.e. one of the most efficient algorithms to compute a maximum flow. 
+ The general algorithm has O(n^2m) time complexity, 
- while the implementation with FIFO vertex selection rule has O(n^3) running time,
+ the highest active vertex selection rule provides O(n^2 \sqrt{m}) time complexity, 
+ the implementation with Sleator's and Tarjan's dynamic tree data structure runs in O(nm log(n^2/m)) time. 
Asymptotically, it is more efficient than the Edmonds-Karp algorithm, which runs in O(nm^2) time.
</text>


<text>
WIKIPEDIA

Given a flow network G(V,E) with capacity from node u to node v given as c(u,v), source s and sink t, we want to find the maximum amount of flow you can send from s to t through the network. Two types of operations are performed on nodes, push and relabel. Throughout we maintain:

- f(u,v) = Flow from u to v. Available capacity is c(u,v) - f(u,v).

- excess(u) = Sum of flow to and from u.

- height(u) = We only push from u to v if height(u) &gt; height(v). 
   For the source, height(s) = n
   For the sink, height(t) = 0
   For all u, height(u) is a non-negative integer
   
For that labeling to be compatible with the preflow, for all edges (v,w) in the residual graph, height(v) \leq height(w)+1 must hold. When a preflow f is compatible with a labeling h, then there is no s-t path in the residual graph G_f. Therefore, it f is a flow compatible with the labeling, then it must be a flow of maximum value.

Where augmenting-path algorithms maintain a feasible flow, preflow-push algorithms maintain a condition that implies the optimality of the preflow once it becomes a flow.



After each step of the algorithm, the flow is a preflow, satisfying:
. The flow between u and v, does not exceed the capacity, i.e. f(u,v) \leq c(u,v)
. We maintain the net flow: f(u,v) = -f(u,v).
. \sum f(u,v) = excess(u) \leq 0  for all nodes u \neq s ; i.e. only the source may produce flow.

Notice that the last condition for a preflow is relaxed from the corresponding condition for a legal flow in a regular flow network.

We observe that the longest possible path from s to t is | V | nodes long. Therefore it must be possible to assign height to the nodes such that for any legal flow, height(s) = | V | and height(t) = 0, and if there is a positive flow from u to v, height(u) &gt; height(v). As we adjust the height of the nodes, the flow goes through the network as water through a landscape. Differing from algorithms such as Ford-Fulkerson, the flow through the network is not necessarily a legal flow throughout the execution of the algorithm.

In short words, the heights of nodes (except s and t) is adjusted, and flow is sent between nodes, until all possible flow has reached t. Then we continue increasing the height of internal nodes until all the flow that went into the network, but did not reach t, has flowed back into s. A node can reach the height 2 | V | - 1 before this is complete, as the longest possible path back to s excluding t is | V | - 1 long, and height(s) = | V | . The height of t is kept at 0.


IDEA: Initially, h(v)=0 for all nodes but the source, h(s)=n. To make a preflow compatible with theis labeling, we make sure that no edges leaving s are in the residual graph, so that f(e)=c(e) for them and f(e)=0 for all other edges. This initial preflow is compatible with the labeling.


Push
A push from u to v means sending a part of the excess flow into u on to v. 

(on any node v with excess flow: if an edge in the residual graph leaves v and goes to a node w at a lower height, we modify f to push some of the excess flow from v to w)


if e is a forward edge
   increase f(e) by \delta = min ( e_f(v), c(e)-f(e) )

if e is a backward edge
   decrease f(e) by \delta = min ( e_f(v), f(e) )


Three conditions must be met for a push to take place:
- excess(u) &gt; 0. More flow into the node than out of it so far.
- c(u,v) - f(u,v) &gt; 0. Available capacity from u to v.
- height(u) &gt; height(v). Can only send to lower node.

We send an amount of flow equal to min(excess(u), c(u,v) - f(u,v)).


Relabel
(when we cannot push the excess of v, we raise v's height and relabel)


When e_f(v) \geq 0 and for all edges (v,w) h(w) \geq h(v)
  Increase h(v)

Doing a relabel on a node u is increasing its height until it is higher than at least one of the nodes it has available capacity to. 
Conditions for a relabel:
- excess(u) &gt; 0. There must be a point in relabelling.
- height(u) &lt; height(v) for all v such that c(u,v) - f(u,v) &gt; 0. The only nodes we have available capacity to are higher.

When relabelling u, we set height(u) to be the lowest value such that height(u) &gt; height(v) for some v where c(u,v) - f(u,v) &gt; 0.


Push-relabel algorithm

Push-relabel algorithms in general have the following layout:

  As long as there is legal push or relabel operation
     Perform a legal push or a legal relabel.



Initialize h(v) and f(e)
while there is a node with excess e_f(v) &gt; 0
   choose a node with excess v
   if there is a node w so that push can be applied
      push flow from v to w
   else
      relabel v



EFFICIENCY

Throughout the algorithm, all nodes have h(v) \leq 2n-1, since there can be up to n-1 edges in a path and the steepness condition implies that the height of the nodes can decrease by at most 1 and, initially, h(s)=n; i.e. h(v)-h(s) \leq |P| \leq n-1. Therefore, each node can be relabeled at most 2n-1 times and the number of relabeling operations is O(n^2)

The number of saturating push operations is at most 2nm and the number of nonsaturating push operations is at most 2n^2m, which determines the running time of the algorithm. In general, the running time for preflow-push algorithms is O(n^2m)

To improve the bound on the number of nonsaturating push operations: If we choose the node with excess at maximum height, the number of nonsaturating push operations is at most 4n^3.

Experimentally, it has been observed that the bottleneck is the number of relabeling operations, so variants of the relabeling operation have been developed to increase labels faster than one by one:

e.g. Use a gap heuristic. If there is a k such that for no node, height(u) = k, you can set height(u) = max(height(u),height(s) + 1) for all nodes except s for which height(u) &gt; k. This is because any such k represents a minimal cut in the graph, and no more flow will go from the nodes S = {u | height(u) &gt; k} to the nodes T = {v | height(v) &lt; k}. If (S,T) was not a minimal cut, there would be an edge (u,v) such that ,  and c(u,v) - f(u,v) &gt; 0. But then height(u) would never be set higher than height(v) + 1, contradicting that height(u) &gt; k and height(v) &lt; k.


IMPLEMENTATION to perform the operations of the algorithm in constant time: 

- Lists of nodes with excess at every possible height

- Adjacency list representation for selecting edges leaving v in the residual graph (both forward and backward edges, linked between them, and including their capacity and flow, so that updates are done in O(1))

- current(v) pointing to the last edge that has been considered for a push operation, advanced after a saturating push operation. Edges will not be reconsidered until the node is relabeled, so the relabel operation will be performed when current(v) reaches the end of the edge list (and we reset it to the first edge after relabeling the node).

Therefore: initial flow and labeling in O(m); push and relabel operations in O(1); each node can be relabeled 2n times and O(d(v)) time advancing the current(v) pointer between relabelings. Dealing with current pointers is then O(\sum_{v \in V} nd(v)) = O(mn) between consecutive relabelings: O(n^2m) generic algorithm, O(n^3) selecting the maximum height node.

</text>

<note>
<text>
Relabel-to-front algorithm, i.e. using FIFO heuristic
In the relabel-to-front algorithm, the order of the push and relabel operations is given:

Send as much flow from s as possible.
Build a list of all vertices except s and t.
As long as we have not traversed the entire list:
   Discharge the current vertex.
   If the height of the current vertex changed:
      Move the current vertex to the front of the list
      Restart the traversal from the front of the list.


Discharge

As long as excess(u) > 0:
   If not all neighbours have been tried since last relabel:
      Try to push flow to an untried neighbour.
   Else:
      Relabel u

NOTE: This requires that for each node, it is known which nodes have been tried since last relabel.


The running time for relabel-to-front is O(n^3)
</text>
</note>


</document>

<document>
<tag>graph-flow-linear-programming</tag>
<title>Network flow as a linear program</title>

<text>
++ linear programming (constraints given by the definition of a legal flow) ++

<url>http://en.wikipedia.org/wiki/Maximum_flow_problem</url>
</text>


</document>

<document>
<tag>graph-flow-linear-programming</tag>
<title>Randomized and approximation algorithms</title>


<text>
+ RANDOMIZED ALGORITHM for minimum cuts @Kleinberg 13.2
[Karger Ph.D. thesis 1995] David R. Karger: Random sampling in graph optimization problems, Ph.D. Thesis, Stanford University, 1995
[Karger and Stein 1996] David R. Karger and Clifford Stein. 1996. A new approach to the minimum cut problem. JACM 43, 4 (July 1996), 601-640. DOI=10.1145/234533.234534 http://doi.acm.org/10.1145/234533.234534

  ABSTRACT: The fundamental principle is simple: the edges in a graph's minimum cut form an extremely small fraction of the graph's edges. Using this idea, we give a randomized, strongly polynomial algorithm that finds the minimum cut in an arbitrarily weighted undirected graph with high probability. The algorithm runs in O(n2log3n) time, a significant improvement over the previous O(mn) time bounds based on maximum flows. It is simple and intuitive and uses no complex data structures. 
  
  Our algorithm can be parallelized to run in RNC with n2 processors; this gives the first proof that the minimum cut problem can be solved in RNC. The algorithm does more than find a single minimum cut; it finds all of them. With minor modifications, our algorithm solves two other problems of interest. Our algorithm finds all cuts with value within a multiplicative factor of agr; of the minimum cut's in expected O(n2 agr;) time, or in RNC with n2 agr; processors. The problem of finding a minimum multiway cut of graph into r pieces is solved in expected O(n2(r-1)) time, or in RNC with n2(r-1) processors.
  
  The "trace" of the algorithm's execution on these two problems forms a new compact data structure for representing all small cuts and all multiway cuts in a graph. This data structure can be efficiently transformed into the more standard cactus representing for minimum cuts.
</text>

<text>
+ APPROXIMATION ALGORITHM The electrical flow algorithm of Christiano, Kelner, Madry, and Spielman finds an approximately optimal maximum flow but only works in undirected graphs.

[Electrical Flows, Laplacian Systems, and Faster Approximation of Maximum Flow in Undirected Graphs , with Paul Christiano, Jonathan Kelner, Daniel Spielman, and Shang-Hua Teng, http://people.csail.mit.edu/madry/docs/maxflow.pdf]
STOC 2011. Best Paper Award. Invited to Journal of the ACM.

Paul Christiano, Jonathan A. Kelner, Aleksander Madry, Daniel A. Spielman, and Shang-Hua Teng. 2011. Electrical flows, laplacian systems, and faster approximation of maximum flow in undirected graphs. In Proceedings of the 43rd annual ACM symposium on Theory of computing (STOC '11). ACM, New York, NY, USA, 273-282. DOI=10.1145/1993636.1993674 http://doi.acm.org/10.1145/1993636.1993674



  ABSTRACT: We introduce a new approach to computing an approximately maximum s-t flow in a capacitated, undirected graph. This flow is computed by solving a sequence of electrical flow problems. Each electrical flow is given by the solution of a system of linear equations in a Laplacian matrix, and thus may be approximately computed in nearly-linear time. Using this approach, we develop the fastest known algorithm for computing approximately maximum s-t flows. For a graph having n vertices and m edges, our algorithm computes a (1-e)-approximately maximum s-t flow in time ~O(mn1/3e-11/3). A dual version of our approach gives the fastest known algorithm for computing a (1+e)-approximately minimum s-t cut. It takes ~O(m+n4/3e-16/3) time. Previously, the best dependence on m and n was achieved by the algorithm of Goldberg and Rao (J. ACM 1998), which can be used to compute approximately maximum s-t flows in time ~O({mvne-1), and approximately minimum s-t cuts in time ~O(m+n3/2e-3).
</text>

</document>


</document>

<!-- Related problems -->

<document>
<tag>graph-flow-variants</tag>
<title>Related problems</title>


<text>
++ @ MIT Graphs - Network flow
</text>

<text>
++ Kleinberg 7 
</text>


<text>
VARIANTS

- multiple sources and/or sinks? - No problem. We can handle
this by modifying the network to create a vertex to serve as a super-source
that feeds all the sources, and a super-sink that drains all the sinks.

- if all arc capacities are identical, either 0 or 1? - Faster algorithms
exist for 0-1 network flows.

- if all my edge costs are identical? - Use the simpler and faster algorithms
for solving maximum flow as opposed to minimum-cost flow. Max-flow
without edge costs arises in many applications, including edge/vertex connectivity
and bipartite matching.

- What if I have multiple types of material moving through the network? - In
a telecommunications network, every message has a given source and destination.
Each destination needs to receive exactly those calls sent to it, not
an equal amount of communication from arbitrary places. This can be modeled
as a multicommodity flow problem, where each call defines a different
commodity and we seek to satisfy all demands without exceeding the total
capacity of any edge. Linear programming will suffice for multicommodity flow if fractional flows
are permitted. Unfortunately, integral multicommodity flow is NP-complete,
even for only two commodities.
</text>

<text>
++ Kleinberg: Disjoint paths (7.6)
- If there are k edge-disjoint paths, the value of the maximum flow is at least k
- If f is a 0-1 valued flow of value k, then the set of edges with f(e)=1 contains a set of v edge-disjoint paths
Ford-Fulkerson algorithm: O(mn) time
</text>

<text>
++ Kleinberg: Circulations with demands (7.7)
- Capacity and demand conditions
- Reducing the circulation problem to the maximum flow problem
...
</text>


<text>
WIKIPEDIA

Multi-source multi-sink maximum flow problem
Given a network N = (V,E) with a set of sources S = {s1, ..., sn} and a set of sinks T = {t1, ..., tm} instead of only one source and one sink, we are to find the maximum flow across N. We can transform the multi-source multi-sink problem into a maximum flow problem by adding a consolidated source connecting to each vertex in S and a consolidated sink connected by each vertex in T with infinite capacity on each edge (See Fig. 4.1.1.).
Fig. 4.1.1. Transformation of a multi-source multi-sink maximum flow problem into a single-source single-sink maximum flow problem

Minimum path cover in directed acyclic graph
Given a directed acyclic graph G = (V, E), we are to find the minimum number of paths to cover each vertex in V. We can construct a bipartite graph G' = (Vout?Vin, E' ) from G, where
Vout = {v?V: v has positive out-degree}.
Vin = {v?V: v has positive in-degree}.
E' = {(u,v)?(Vout,Vin): (u,v)?E}.
Then it can be shown that G' has a matching of size m if and only if there exists n-m paths that cover each vertex in G, where n is the number of vertices in G. Therefore, the problem can be solved by finding the maximum cardinality matching in G' instead.


Maximum cardinality bipartite matching
Given a bipartite graph G = (X?Y, E), we are to find a maximum cardinality matching in G, that is a matching that contains the largest possible number of edges. This problem can be transformed into a maximum flow problem by constructing a network N = (X?Y?{s,t}, E' }, where
E' contains the edges in G directed from X to Y.
(s,x)?E' for each x?X and (y,t)?E' for each y?Y.
c(e) = 1 for each e?E' (See Fig. 4.3.1).
Then the value of the maximum flow in N is equal to the size of the maximum matching in G.
Fig. 4.3.1. Transformation of a maximum bipartite matching problem into a maximum flow problem
e.g. O(mn) using the Ford-Fulkerson algorithm


Maximum flow problem with vertex capacities
Given a network N = (V, E), in which there is capacity at each node in addition to edge capacity, that is, a mapping c: V?R+, denoted by c(v), such that the flow f has to satisfy not only the capacity constraint and the conservation of flows, but also the vertex capacity constraint
Si?Vfiv = c(v) for each v?V\{s,t}.
In other words, the amount of flow passing through a vertex cannot exceed its capacity.
To find the maximum flow across N, we can transform the problem into the maximum flow problem in the original sense by expanding N. First, each v?V is replaced by vin and vout, where vin is connected by edges going into v and vout is connected to edges coming out from v, then assign capacity c(v) to the edge connecting vin and vout (See Fig. 4.4.1). In this expanded network, the vertex capacity constraint is removed and therefore the problem can be treated as the original maximum flow problem.
Fig. 4.4.1. Transformation of a maximum flow problem with vertex capacities constraint into the original maximum flow problem by node splitting

Maximum independent path
Given a directed graph G = (V, E) and two vertices s and t, we are to find the maximum number of independent paths from s to t. Two paths are said to be independent if they do not have a vertex in common apart from s and t. We can construct a network N = (V, E) from G with vertex capacities, where
s and t are the source and the sink of N respectively.
c(v) = 1 for each v?V.
c(e) = 1 for each e?E.
Then the value of the maximum flow is equal to the maximum number of independent paths from s to t.

Maximum edge-disjoint path
Given a directed graph G = (V, E) and two vertices s and t, we are to find the maximum number of edge-disjoint paths from s to t. This problem can be transformed to a maximum flow problem by constructing a network N = (V, E) from G with s and t being the source and the sink of N respectively and assign each edge with unit capacity.
</text>

<text>
More related problems:
++ Connectivity: Finding edge-disjoint paths (equivalent to the maximum-flow problem)
ref. Menger's theorem <cite>Menger 1927</cite> <cite>Menger 1981</cite>
Kerl Menger (1902-1985)
[Karl Menger: "Zur allgemeinen Kurventheorie ("For the General Theory of Curves", in German), Fundamenta Mathematicae 19:96-115, 1927]
[Karl Menger: On the origin of the n-arc theorem, Journal of Graph Theory 5:4 (1981), 341-350. DOI: 10.1002/jgt.3190050402 ]
<url>http://en.wikipedia.org/wiki/Menger's_theorem</url>
</text>

<document>
<tag>graph-minimum-cuts</tag>
<title>Minimum cuts</title>

<text>
A set of edges whose deletion separates s from t is called an s-t cut. Since no s-t flow can exceed the weight of the minimum s-t cut, finding the maximum flow is equivalent to discovering the minimum cut. In fact, the maximum s-t flow equals the weight of the minimum s-t cut. This maximum-flow, minimum-cut theorem is due to <cite>Ford and Fulkerson 1962</cite>.
</text>

<text>
Therefore, flow algorithms can be used to solve edge and vertex connectivity problems that are employed to answer questions such as
What is the smallest subset of vertices (or edges) whose deletion will disconnect G? Or which will separate s from t? Such problem often appear when stuydying network reliability.
</text>


<text>
<url>http://en.wikipedia.org/wiki/Max-flow_min-cut_theorem</url>
the max-flow min-cut theorem states that in a flow network, the maximum amount of flow passing from the source to the sink is equal to the minimum capacity which when removed in a specific way from the network causes the situation that no flow can pass from the source to the sink.
NOTE: The max-flow min-cut theorem is a special case of the duality theorem for linear programs and can be used to derive Menger's theorem (a basic result about connectivity in finite undirected graphs) and the König-Egerváry Theorem (which  describes an equivalence between the maximum matching problem and the minimum vertex cover problem in bipartite graphs).

NOTE++ In optimization theory, the duality principle states that optimization problems may be viewed from either of two perspectives, the primal problem or the dual problem, i.e. it is often possible to convert the primal problem (i.e. the original form of the optimization problem) to a dual form, which is termed a dual problem.
</text>

<text>
In fact, as reported by <cite>Schrijver 2002</cite>, the original motivation of this problem was related to disrupting the railway transportation network through the Soviet Union, at least according to declassified U.S. Air Force documents.
</text>

<text>
"The edge (vertex) connectivity of a graph G is the smallest number of edge
(vertex) deletions sufficient to disconnect G. There is a close relationship between
the two quantities. The vertex connectivity is always less than or equal to the
edge connectivity, since deleting one vertex from each edge in a cut set succeeds
in disconnecting the graph. But smaller vertex subsets may be possible. The minimum
vertex degree is an upper bound for both edge and vertex connectivity, since
deleting all its neighbors (or cutting the edges to all its neighbors) disconnects the
graph into one big and one single-vertex component"
</text>

<text>
- Simple depth-first or breadth-first traversals suffice to identify all connected components in linear time, including strongly-connected and weakly-connected components in directed graphs.

- Weak links: We say that G is biconnected if no single vertex deletion is sufficient to disconnect G. Any vertex that is such a
weak point is called an articulation vertex. A bridge is the analogous concept for edges, meaning a single edge whose deletion disconnects the graph. Linear-time algorithms for identifying articulation vertices and bridges also exist.

- Finding the smallest cut-set that separates a given pair of vertices can be solved using network flow algorithms: Given a network flow of maximum value, we can compute a minimum cut in O(m) time just by performing a breadth-first search on the residual graph. The set A* of all the nodes reachable from s and its complement, i.e. B*=V-A*, determine the minimum cut (A*,B*). 

- Vertex connectivity is characterized by Menger's theorem, which states that a graph is k-connected if and only if every pair of vertices is joined by at least k vertex-disjoint paths. Network flow can again be used to perform this calculation, since a flow of k between a pair of vertices implies k edge-disjoint paths. we construct a graph G' such that any set of edge-disjoint paths in G' corresponds to vertex-disjoint paths in G. This is done by replacing each vertex vi of G with two vertices vi,1 and vi,2, such that edge (vi,1, vi,2)  G' for all vi G, and by replacing every edge (vi, x) in G by edges (vi,j, xk), j = k {0, 1} in G'. Thus two edge-disjoint paths in G' correspond to each vertex-disjoint path
in G.

A non-flow-based algorithm for edge k-connectivity in O(kn2) is due to Matula <cite>Matula 1987</cite>.
Faster k-connectivity algorithms are known for certain small values of k. All three-connected components of a graph can be generated in linear time <cite>Hopcroft and Tarjan 1973b</cite>, while O(n2) suffices to test 4-connectivity <cite>Kanevsky and Ramachandran 1991</cite>

- Graph partitioning, i.e. splitting the graph into smaller components with specific properties, is, however, an NP-complete problem. Good heuristic techniques exist for this problem <cite>Karypis and Kumar 1999</cite>, which has important applications (e.g. in VLSI circuit layout).

<!-- Tools:
- Chaco: partition graphs for parallel computing applications http://www.cs.sandia.gov/¡«bahendr/chaco.html.
- METIS (http://glaros.dtc.umn.edu/gkhome/views/metis)successfully partitioned graphs with over 1,000,000 vertices.
- Scotch (http://www.labri.fr/perso/pelegrin/scotch/)
- JOSTLE (http://staffweb.cms.gre.ac.uk/¡«wc06/jostle/)
-->

</text>

</document>

<document>
<tag>graph-matching</tag>
<title>Matching</title>

<text>
A matching in a graph <eqn>G=(V,E)</eqn> is a subset of edges <eqn>E' \subset E</eqn> such that no two edges in <eqn>E'</eqn> share a vertex.
</text>

<text>
++ Kleinberg 404-414
</text>

<text>
PROBLEM
Find the largest set of edges E' from E such that each
vertex in V is incident to at most one edge of E'.
</text>

<text>
APPLICATION: Assignment problems, with/without weights (maximum cardinality matching/ maximum weight matching).
- Assignment problems (jobs to be done and people who can do them, male and female customers of a dating web site...)
</text>

<text>
Matching theory and algorithms <cite>Lovasz and Plummer 1986</cite>
</text>

<text>
++ CS 
      A matching in a graph is a subset of edges
that have no common incident vertices. It captures the notion of pairing
off compatible vertices. The maximum matching problem is that of finding
a matching of maximum cardinality. Hall and Tutte gave necessary and
sufficient conditions for a graph to have a perfect matching - a matching
in which all vertices are matched. Edmonds gave a polynomial-time algorithm
for finding a maximum matching. Edges may be assigned weights that denote
the advantage of including them in a matching. Maximum-weight bipartite
matching, also known as the assignment problem, arises in many applications.
Algorithms for maximum cardinality and maximum-weight matchings have been
well studied.  See <cite>Ahuja et al. 1993</cite>,<cite>Bondy and Murty 1976</cite>, 
, and <cite>Papadimitriou and Steiglitz 1982</cite>
for more details.
</text>

<text>
Standard algorithms for bipartite matching based on network flows:
</text>

<text>
Remember that a graph is bipartite (or two-colorable) if its vertices can be divided into two sets, L and R, so that every edge in the graph connects one vertex from the first set to a different vertex on the second set.
</text>

<text>
The largest possible bipartite matching can be found using network flow. Just add a source node s connected to every vertex in L with capacity 1, add a sink node t connected to every node in R, and assign each edge in the bipartite graph a capacity of 1. The maximum flow from s to t determines the largest matching in the bipartite graph.
</text>

<text>
The best algorithm for maximum bipartite matching, based on Hopcroft and Karp's algorithm <cite>Hopcroft and Karp 1973</cite>, repeatedly finds the shortest augmenting paths instead of using network flow, and runs in <eqn>O(\sqrt{n}m)</eqn> <cite>Micali and Vazirani 1980</cite>.
</text>

<text>
Classic algorithm: Hungarian algorithm for bipartite matching <cite>Kuhn 1955</cite>. The Hungarian algorithm runs in <eqn>O(n(m + n \log n))</eqn> time and predates work on network flow algorithms.
</text>

<text>
HISTORY: 
<cite>Hall 1935</cite> 
[P. Hall: "On representation of subsets", J. London Mathematical Society 10:26,30, 1935]
<cite>Konig 1916</cite>
[D. König: "Uber Graphen und ihre Anwendung auf Determinantentheorie und Memgenlehre" (About graphs and their application to set theory and the theory of determinants, in German), Mamathemastische Annalen, 77:453-465, 1916]
</text>

<text>
Matching based on preferences (e.g. matching medical residents to hospitals or students to university courses): <eqn>O(n^2)</eqn> time using Galey and Shapley's algorithm <cite>Gale and Shapley 1962</cite>.
</text>


<text>
@ MIT Graphs - Matching
</text>


</document>

</document>

</document>

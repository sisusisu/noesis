<?xml version="1.0"  encoding="ISO-8859-1" ?> 
<!DOCTYPE sys-ents [ <!ENTITY bibliography SYSTEM "bibliography.xml"> ]> 
<?xml-stylesheet type="text/xsl" href="../book.xsl"?>


<document>
&bibliography;
<title>Graph Visualization</title>


<document>
<tag>graph-visualization-techniques</tag>
<title>Graph drawing techniques</title>

<text>
Ill-defined problem: Draw a graph G so as to accurately reflect its structure (and the drawing is aesthetically pleasing).
</text>

<text>
Suitable for small and medium-sized networks...

1600x1200 pixels to display thousand of edges results in just a blob (interactive visualization might help to explore the neighborhood of a given set of nodes, though)
</text>


<text>
Potential evaluation, and often conflicting, criteria (warning! not an optimization problem):

- as few crossing edges as possible, since they can be confusing (computing the crossing number of a graph is NP-complete)
- compact drawing (judicious use of white space)
- aspect ratio (width/height suitable for the desired output device)
- avoid long edges (hard to follow, obscure details)
- avoid small angles (overlap, poor printing/visualization on screen)
</text>

<text>
Design decisions 
SKIENA 2008 
"Must the edges be straight, or can I have curves and/or bends? – Straight-line
drawing algorithms are relatively simple, but have their limitations. Orthogonal
polyline drawings seem to work best to visualize complicated graphs
such as circuit designs. Orthogonal means that all lines must be drawn either
horizontal or vertical, with no intermediate slopes. Polyline means that each
graph edge is represented by a chain of straight-line segments, connected by
vertices or bends.

- Is there a natural, application-specific drawing? – If your graph represents a
network of cities and roads, you are unlikely to find a better drawing than
placing the vertices in the same position as the cities on a map. This same
principle holds for many different applications.

- Is your graph either planar or a tree? – If so, use one of the special planar
graph or tree drawing algorithms of Sections 15.11 and 15.12.

- Is your graph directed? – Edge direction has a significant impact on the nature
of the desired drawing. When drawing directed acyclic graphs (DAGs), it is
often important that all edges flow in a logical direction—perhaps left-right
or top-down.

- How fast must your algorithm be? – Your graph drawing algorithm had better
be very fast if it will be used for interactive update and display. You are
presumably limited to using incremental algorithms, which change the vertex
positions only in the immediate neighborhood of the edited vertex. You can
afford more time for optimization if instead you are printing a pretty picture
for extended study.

- Does your graph contain symmetries? – The output drawing above is attractive
because the graph contains symmetries—namely two vertices identically
connected to a core K5. The inherent symmetries in a graph can be identified
by computing its automorphisms, or self-isomorphisms. Graph isomorphism
codes (see Section 16.9 (page 550)) can be readily used to find all automorphisms.

- Drawing your graph opens another can of worms, namely where to place the
edge/vertex labels. We seek to position labels very close to the edges or vertices
they identify, and yet to place them such that they do not overlap each other or
other important graph features. Optimizing label placement can be shown to be
an NP-complete problem, but heuristics related to bin packing (see Section 17.9
(page 595)) can be effectively used. Map-labeling heuristics are described in [BDY06, WW95].
"

[BDY06]
K. Been, E. Daiches, and C. Yap. Dynamic map labeling. IEEE Trans.
Visualization and Computer Graphics, 12:773–780, 2006.
[WW95] 
F. Wagner and A. Wolff. Map labeling heuristics: provably good and practically
useful. In Proc. 11th ACM Symp. Computational Geometry, pages
109–118, 1995.

</text>


<text>
QUICK AND DIRTY DRAWING: 
"simply spacing the vertices
evenly on a circle, and then drawing the edges as straight lines between vertices.
Such drawings are easy to program and fast to construct. They have the substantial
advantage that no two edges will obscure each other, since no three vertices will be
collinear. Such artifacts can be hard to avoid as soon as you allow internal vertices
into your drawing. An unexpected pleasure with circular drawings is the symmetry
sometimes revealed because vertices appear in the order they were inserted into
the graph. Simulated annealing can be used to permute the circular vertex order
to minimize crossings or edge length, and thus significantly improve the drawing."
</text>

<text>
OTHER SIMPLE SITUATION
Bipartite graphs
</text>

</document>



<document>
<tag>graph-visualization-force</tag>
<title>Force-directed methods</title>

<text>
"a good, general purpose graph-drawing heuristic models the graph as a system
of springs and then uses energy minimization to space the vertices. Let adjacent
vertices attract each other with a force proportional to (say) the logarithm of their
separation, while all nonadjacent vertices repel each other with a force proportional
to their separation distance. These weights provide incentive for all edges to be
as short as possible, while spreading the vertices apart. The behavior of such a
system can be approximated by determining the force acting on each vertex at a
particular time and then moving each vertex a small amount in the appropriate
direction. After several such iterations, the system should stabilize on a reasonable
drawing."
</text>


<text>
An example <type>graph drawing</type> algorithm is shown in Figure <ref>force-based</ref>.
</text>

<figure>
<title>Force-based algorithm.</title>
<tag>force-based</tag>
<code>
 set up initial node velocities to (0,0)
 set up initial node positions randomly // make sure no 2 nodes are in exactly the same position
 loop
     total_kinetic_energy := 0 // running sum of total kinetic energy over all particles
     for each node
         net-force := (0, 0) // running sum of total force on this particular node
         
         for each other node
             net-force := net-force + Coulomb_repulsion( this_node, other_node )
         next node
         
         for each spring connected to this node
             net-force := net-force + Hooke_attraction( this_node, spring )
         next spring
         
         // without damping, it moves forever
         this_node.velocity := (this_node.velocity + timestep * net-force) * damping
         this_node.position := this_node.position + timestep * this_node.velocity
         total_kinetic_energy := total_kinetic_energy + this_node.mass * (this_node.velocity)^2
     next node
 until total_kinetic_energy is less than some small number  // the simulation has stopped moving
</code>
</figure>


<text>
++ The Kamada-Kawai's graph drawing algorithm, chosen for its ability to represent
naturally the most important elements in the center of the representation (the backbone), <cite>Kamada and Kawai 1989</cite>
</text>

</document>

<document>
<tag>graph-visualization-hierarchical</tag>
<title>Hierarchical methods</title>


<text>
++ BASED ON TOPOLOGICAL SORTING Layered graph drawing is a type of graph drawing in which the vertices of a directed graph are drawn in horizontal rows or layers with the edges generally directed downwards. It is also known as Sugiyama-style graph drawing after Kozo Sugiyama, who first developed this drawing style.

ref. Sugiyama, Kozo; Tagawa, Shôjirô; Toda, Mitsuhiko (1981), "Methods for visual understanding of hierarchical system structures", IEEE Transactions on Systems, Man, and Cybernetics SMC-11 (2): 109-125, doi:10.1109/TSMC.1981.4308636, MR0611436.


++ A minimal feedback arc set (one that can not be reduced in size by removing any edges) has the additional property that, if the edges in it are reversed rather than removed, then the graph remains acyclic. Finding a small edge set with this property is a key step in layered graph drawing

Di Battista, Giuseppe; Eades, Peter; Tamassia, Roberto; Tollis, Ioannis G. (1998), "Layered Drawings of Digraphs", Graph Drawing: Algorithms for the Visualization of Graphs, Prentice Hall, pp. 265–302, ISBN 9780133016154.

astert, Oliver; Matuszewski, Christian (2001), "Layered drawings of digraphs", in Kaufmann, Michael; Wagner, Dorothea, Drawing Graphs: Methods and Models, Lecture Notes in Computer Science, 2025, Springer-Verlag, pp. 87–120, doi:10.1007/3-540-44969-8_5.


++ http://en.wikipedia.org/wiki/Layered_graph_drawing
</text>

</document>




<document>
<tag>graph-visualization-metrics</tag>
<title>Metrics-based methods</title>
</document>





<document>
<tag>graph-visualization-specific</tag>
<title>Specific methods</title>


<document>
<tag>graph-visualization-planar</tag>
<title>Planar graphs</title>

SKIENA

Can G be drawn in the plane such that no two edges cross? If so, produce such a drawing.

Planar drawings (or embeddings) make clear the structure of a given
graph by eliminating crossing edges, which can be confused as additional vertices.
Graphs defined by road networks, printed circuit board layouts, and the like are
inherently planar because they are completely defined by surface structures.


NOTE: Obstructing subgraphs K3,3 K5

+ Kuratowski [Kur30] gave the first characterization of planar graphs, namely that
they do not contain a subgraph homeomorphic to K3,3 or K5. Thus, if you are still
working on the exercise to embed K5, now is an appropriate time to give it up.

[Kur30] K. Kuratowski. Sur le problème des courbes gauches en topologie. Fund.
Math., 15:217-283, 1930.


+ Fary's theorem [F'48] states that every planar graph can be drawn in such a way that each edge
is straight.

[Fary 48]I. Fáry. On straight line representation of planar graphs. Acta. Sci. Math. Szeged, 11:229–233, 1948.


++ Outerplanar graphs are those that can be drawn so all vertices lie on the outer face
of the drawing. Such graphs can be characterized as having no subgraph homeomorphic
to K2,3 and can be recognized and embedded in linear time.



Planar graphs have a variety of nice properties that can be exploited to yield
faster algorithms for many problems. The most important fact to know is that
every planar graph is sparse. Euler's formula shows that |E| lt 3|V| - 6 for every
nontrivial planar graph G = (V,E). This means that every planar graph contains
a linear number of edges, and further that every planar graph contains a vertex of
degree lt 5. Every subgraph of a planar graph is planar, so there must always a
sequence of low-degree vertices to delete from G, reducing it to th



Thus, it pays to distinguish the problem of planarity testing (does a graph
have a planar drawing?) from constructing planar embeddings (actually finding
the drawing), although both can be done in linear time.

Algorithms for planarity testing begin by embedding an arbitrary cycle from the
graph in the plane and then considering additional paths in G, connecting vertices
on this cycle. Whenever two such paths cross, one must be drawn outside the cycle
and one inside. When three such paths mutually cross, there is no way to resolve
the problem, so the graph cannot be planar. Linear-time algorithms for planarity
detection are based on depth-first search, but they are subtle...

Such path-crossing algorithms can be used to construct a planar embedding by
inserting the paths into the drawing one by one. Unfortunately, because they work
in an incremental manner, nothing prevents them from inserting many vertices and
edges into a relatively small area of the drawing. Such cramping is a major problem,
for it leads to ugly drawings that are hard to understand.

Better algorithms have
been devised that construct planar-grid embeddings, where each vertex lies on a
(2n - 4) x (n - 2) grid. Thus, no region can get too cramped and no edge can
get too long. Still, the resulting drawings tend not to look as natural as one might
hope.

For nonplanar graphs, what is often sought is a drawing that minimizes the
number of crossings. Unfortunately, computing the crossing number of a graph is
NP-complete. A useful heuristic extracts a large planar subgraph of G, embeds this
subgraph, and then inserts the remaining edges one by one to minimize the number
of crossings. This won't do much for dense graphs, which are doomed to have a large
number of crossings, but it will work well for graphs that are almost planar, such
as road networks with overpasses or printed circuit boards with multiple layers.
Large planar subgraphs can be found by modifying planarity-testing algorithms to
delete troublemaking edges when encountered.


REFERENCES

Hopcroft and Tarjan [HT74] gave the first linear-time algorithm for drawing graphs.

[HT74]
J. Hopcroft and R. Tarjan. Efficient planarity testing. J. ACM, 21:549–568, 1974.


Booth and Lueker [BL76] developed an alternate planarity-testing algorithm based on PQ-trees.

[BL76] K. Booth and G. Lueker. Testing for the consecutive ones property, interval
graphs, and planarity using PQ-tree algorithms. J. Computer System Sciences, 13:335–379, 1976.


Simplified planarity-testing algorithms include [BCPB04, MM96, SH99]. 

[BCPB04] J. Boyer, P. Cortese, M. Patrignani, and G. Di Battista. Stop minding your
p's and q's: Implementing a fast and simple DFS-based planarity testing
and embedding algorithm. In Proc. Graph Drawing (GD ’03), volume 2912
LNCS, pages 25–36, 2004.

[MM96] K. Mehlhorn and P. Mutzel. On the embedding phase of the Hopcroft and
Tarjan planarity testing algorithm. Algorithmica, 16:233–242, 1996.

[SH99] W. Shih and W. Hsu. A new planarity test. Theoretical Computer Science,
223(1–2):179–191, 1999.


Efficient 2n x n planar grid embeddings were first developed by [dFPP90]. 

[dFPP90] H. de Fraysseix, J. Pach, and R. Pollack. How to draw a planar graph on a
grid. Combinatorica, 10:41–51, 1990.


The book by Nishizeki and Rahman [NR04] provides a good overview of the spectrum of planar drawing
algorithms.

[NR04] T. Nishizeki and S. Rahman. Planar Graph Drawing. World Scientific, 2004.

</document>

<document>
<tag>graph-visualization-trees</tag>
<title>Trees</title>

Create a nice drawing of trees, i.e. graphs without cycles (always planar, can be drawn without edge crossings)


SKIENA

- Rooted trees define a hierarchical order, emanating from a single source node
identified as the root. Any drawing should reflect this hierarchical structure,
as well as any additional application-dependent constraints on the order in
which children must appear. For example, family trees are rooted, with sibling
nodes typically drawn from left to right in the order of birth.

- Free trees do not encode any structure beyond their connection topology.
There is no root associated with the minimum spanning tree (MST) of a
graph, so a hierarchical drawing will be misleading. Such free trees might
well inherit their drawing from that of the full underlying graph, such as the
map of the cities whose distances define the MST."


TECHNIQUES

- Any of the techniques for planar graphs (might be too general, too slow for particular applications).

- Assume a root is present (e.g. a center vertex might be suitable). For trees, the center always consists of either one vertex or two
adjacent vertices. This tree center can be identified in linear time by repeatedly trimming all the leaves until only the center remains.

a) Ranked embeddings – "Place the root in the top center of your page, and then
partition the page into the root-degree number of top-down strips. Deleting
the root creates the root-degree number of subtrees, each of which is assigned
to its own strip. Draw each subtree recursively, by placing its new root (the
vertex adjacent to the old root) in the center of its strip a fixed distance down
from the top, with a line from old root to new root. The output figure above
is a nicely ranked embedding of a balanced binary tree.
Such ranked embeddings are particularly effective for rooted trees used to
represent a hierarchy—be it a family tree, data structure, or corporate ladder.
The top-down distance illustrates how far each node is from the root.
Unfortunately, such repeated subdivision eventually produces very narrow
strips, until most of the vertices are crammed into a small region of the page.
Try to adjust the width of each strip to reflect the total number of nodes it
will contain, and don't be afraid of expanding into neighboring region's turf
once their shorter subtrees have been completed."

b) Radial embeddings – "Free trees are better drawn using a radial embedding,
where the root/center of the tree is placed in the center of the drawing.
The space around this center vertex is divided into angular sectors for each
subtree. Although the same problem of cramping will eventually occur, radial
embeddings make better use of space than ranked embeddings and appear
considerably more natural for free trees. The rankings of vertices in terms of
distance from the center is illustrated by the concentric circles of vertices."



REFERENCES

Heuristics for tree layout have been studied by several researchers [RT81, Moe90],

[RT81] E. Reingold and J. Tilford. Tidier drawings of trees. IEEE Trans. Software Engineering, 7:223–228, 1981.

[Moe90] S. Moen. Drawing dynamic trees. IEEE Software, 7-4:21–28, 1990.


with Buchheim, et al. [BJL06] reflective of the state-of-the-art. 

[BJL06] C. Buchheim, M. Jünger, and S. Leipert. Drawing rooted trees in linear time. Software: Practice and Experience, 36:651–665, 2006.


Under certain aesthetic criteria, the problem is NP-complete [SR83].

[SR83] K. Supowit and E. Reingold. The complexity of drawing trees nicely. Acta Informatica, 18:377–392, 1983.
</document>


</document>

<document>
<tag>graph-visualization-tools</tag>
<title>Graph visualization tools</title>


<text>
TOOLS: 
- Design patterns <cite>Heer and Agrawala 2006</cite>
- JSNVA network drawing framework <cite>Ye et al. 2008</cite>
- VisNetMiner <cite>Shi et al. 2009</cite>
</text>

<text>
Systems described in [JM03]...
[JM03] M. Jünger and P. Mutzel. Graph Drawing Software. Springer-Verlag, 2003.
</text>

<list>

<item>Graphviz, http://www.graphviz.org, graph-drawing program developed by Stephen North of Bell Laboratories: represents edges as splines and can construct useful drawings of quite large and complicated graphs.</item>

<item>JGraph, <url>http://www.jgraph.com/</url>, and JGraphT, <url>http://jgrapht.sourceforge.net/</url>: Java graph libraries suitable for interactive
applications.


++ JGraphEd (http://www.jharris.ca/JGraphEd/): a Java graph-drawing framework
that includes several planarity testing/embedding algorithms, including both
the Booth-Lueker PQ-tree algorithm and the modern straight-line grid embedding
</item>

<item>Social network analysis tools: Pajek, NodeXL...</item>

</list>


</document>



<document>
<tag>graph-visualization-notes</tag>
<title>Bibliographic notes</title>

<text>
ALGORITHMS

- Force-directed drawing  <cite>Fruchterman and Reingold 1991</cite>

- Kamada <cite>Kamada and Kawai 1989</cite> <cite>Kamada and Kawai 1991</cite>

</text>


<text>
TOOLS: 
- Design patterns <cite>Heer and Agrawala 2006</cite>
- JSNVA network drawing framework <cite>Ye et al. 2008</cite>
- VisNetMiner <cite>Shi et al. 2009</cite>
</text>

<text>
Chapters <cite>Cook and Holder 2007</cite> (succinct survey) <cite>Skiena 2008</cite> (sections for arbitrary graphs, trees, and planar graphs)
</text>

<text>
Monographs <cite>Di Battista et al. 1999</cite>
- Recent survey of visualization techniques <cite>Aigner et al. 2011</cite>
- Focus on software: the development and evaluation of methods for graphically representing different aspects of software, including its structure, its execution, and its evolution <cite>Sugiyama 2002</cite>; <cite>Diehl 2007</cite>
- Focus on biology: <cite>Guimera and Nunes 2005</cite>
- General literature on visualization, what makes visualization aesthetically pleasing <cite>Cleveland 1985</cite> <cite>Tufte 2001</cite> <cite>Steele and Iliinsy 2010</cite>
</text>

<text>
Annual conference on graph drawing (proceedings published by Springer-Verlag's Lecture Notes in Computer Science series)
</text>

+Kaufmann and Wagner [KW01]
[KW01] M. Kaufmann and D. Wagner. Drawing Graphs: Methods and Models. Springer-Verlag, 2001.

+Jünger and Mutzel [JM03] is organized around systems instead of algorithms, but provides technical details about the drawing
methods each system employs. 
[JM03] M. Jünger and P. Mutzel. Graph Drawing Software. Springer-Verlag, 2003.




[BS] U. Brandes and S. Cornelsen, Visual Rank of Link Structures, Journal of Graph
Algorithms and Applications, vol. 7, no. 2, pp. 181-201, 2003.

[KCH] Y. Koren, L. Carmel and D. Harel, Drawing Huge Graphs by Algebraic Multigrid
Optimization, Multiscale Modeling and Simulation, Volume 1, no. 4, pp.
645-673, SIAM, 2003

[Ko] Y. Koren, Drawing Graphs by Eigenvectors: Theory and Practice, Computers
and Mathematics with Applications, Elsevier, to appear.



</document>


</document>
